1. 子类中访问父类中的私有属性和私有方法
	如果想使用父类中的私有属性和私有方法,那么就需要在父类中,为这些私有的属性和方法,提供相应的公有的接口方法来间接访问
	
2. 如何为父类中的属性进行初始化
	
	在子类中如果定义了自己的初始化方法,那么这时父类的初始化方法就不会再执行了
	那么就导致父类中定义的属性无法初始化,子类对象就无法使用继承自父类的属性
	如果想正常初始化,需要在子类的初始化方法中,手动调用父类的初始化方法
	现阶段调用格式:
	父类名.__init__(self,父类中需要属性参数列表)


3. 子类中重写和调用父类的方法
	在子类继承父类时,子类会拥有父类中的方法.
	但是子类并不需要或不满足父类方法中提供的功能,这时就需进行对父类方法重写

	重写之后,调用该方法时,执行谁?
	答案: 调用重写后子类中的方法


4. 子类方法中调用父类的同名方法


5. 多层继承
	继承关系有多层,祖孙三代

	查找方法:
	
	父类名.方法名(self)
		



6. 多继承
	
	格式:
	class 类名(父类名1,.....):
		pass


7. 多继承的初始化
	父类名调用  理解
	super()调用  使用
	super(类名，self) 了解 

	super执行过程:
	在 self 这个对象的所属类中,通过 __mro__ 找到方法解析顺序
	在顺序中,找当前类名的下一个类来初始化或查找方法


	在多继承时,如果继承的多个类同时继承同一个父类,那么这时会出现初始化问题
	这个共同父类会被初始化多次.

	类名.__mro__ 得到了一个元组,元组中的元素是当前类在继承关系上的一个顺序

	方法解析顺序
	method relational ordered

	这个顺序不是我们确定的,是由在确定某个类的继承关系关系后,由解释器来确定这个顺序


	super对象是基于类的mro顺序来对当前类进行初始化的
	基于这个mro顺序可以保证,所有的继承关系的上类,都只执行一次


	mro -> 一个类的继承书写顺序会影响mro顺序
	

8. 多继承调用指定父类中方法
		父类名.方法（）
		super().方法()


9.  多态
	多种形态
	程序中的意义:
		当调用一个方法名的时候,得到的结果不同
		在一般的面向对象语言中,多态是由继承来实现的
		但是在python中,python,天生具有多态性


    鸭子类型： Duck Typing
    	一只鸟如果长的鸭子,叫声像鸭子,那么就认为它就是鸭子







10. 实例对象属性和实例对象方法
	
	以 对象名.xxx  的形式调用的都是实例的属性或实例的方法
	
	
	实例属性和实例方法只能由实例对象调用


11. 类对象和类属性

	类属性可以使用实例对象来引用,但是不能修改
	一般情况下:类属性 都只使用 类对象 来调用
	
	类对象.类属性




12. 类方法


13. 静态方法

注意：super关键字实现继承时是按照__mro__显示的继承顺序开始初始化的，首先是执行该类的第一个直接父类，由于父类的参数不唯一，容易造成指定参数出错，因此父类中super关键字
里面的参数只写当前类的参数即可，其他的用*args可变参数代替，然后在子类传参时，自动穿入合适的参数去执行程序，剩余参数传到顺序下一个父类。下一个父类如果和上一个父类继承
了同一个父类，重写了__init__方法且都继承了上一个父类的属性，那么这个属性会在第一个父类执行时进行初始化，在第二个父类执行时由于是可变参数，就不用再初始化了。
